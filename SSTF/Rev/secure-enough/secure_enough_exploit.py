from ctypes import c_int, c_uint
from Crypto.PublicKey import RSA
from Crypto.Cipher import AES
import hashlib  # md5 
import struct
import binascii

from Crypto.Util.py3compat import b
timestamp = 1624347317

# ref
# https://gist.github.com/integeruser/4cca768836c68751904fe215c94e914c
def srand(seed):
    srand.r = [0 for _ in range(34)]
    srand.r[0] = c_int(seed).value
    for i in range(1, 31):
        srand.r[i] = (16807 * srand.r[i - 1]) % 2147483647
    for i in range(31, 34):
        srand.r[i] = srand.r[i - 31]
    srand.k = 0
    for _ in range(34, 344):
        rand()


def rand():
    srand.r[srand.k] = srand.r[(srand.k - 31) % 34] + srand.r[(srand.k - 3) % 34]
    r = c_uint(srand.r[srand.k]).value >> 1
    srand.k = (srand.k + 1) % 34
    return r

srand(timestamp)
tmp1 = hashlib.md5(struct.pack('<I', rand())).digest()
tmp2 = hashlib.md5(struct.pack('<I', rand())).digest()
generate = tmp1+tmp2
md51 = generate
print(type(generate))
# b'\xa3\xe6\xf4\x84\xd7\x86Z\xb1\x05n\x15\x83<t\x8b\xed\xb6\x89\xc0a?\xa1\x14j5\xf1)yzw\x05\x14'

# PoC (via packet 04)
test = "01a3e6f484d7865ab1056e15833c748bedb689c0613fa1146a35f129797a7705142e9041559d7b0efb5cca1ec10310091de88fe3d3b85df5862be216ae07c13a25b3554692c441e9a3574275a6b3f3cb7f70e4c4967e7f893fdff2d8279f70d53a9265aea14c86b560e97e813cec1d03ef819d276d0e7e1c0809dabb367dc85c387a2ebc79e2740a89f1b119c7ee978d436b6389cc2be163670f4fb82dd96801cf5d9626f8b903c039b06e7d0d8cfeceb2c21ec6054843628499bd12a741d2d35bdd4361f07148cae759833a4a1ea15d6874c21cafa4934eab3debff36252149a11407bf4196cf18242937757ae408856f1e654a25d9d75849df2b664c6886ee97d5a940d73faf9625b709beda7c1d0f171ca061fe3bf0e6232592d817f9a4a6a60000"
md5_test = binascii.unhexlify(test[2:2 + len(generate*2)])
md52 = md5_test

if md5_test == generate:
    print("Great")

else:
    exit(0)

# RSA decrypt
# c^d mod n (fermat's little theorom)
# pow(c,d,n)


#c = "020f4b82b9d771a2625de1339269ead8599308a5119f3c8a3eb2e266f04210c2ac7e5657072ecd5fb777a99a8d57d94e39fa7001dd926ac42e4e9c944cd086868605d59db718caf0738f9983575119e4ae63f84c7a274eba7b39b9dc19a749a9bca7bead0aa75ea8f2c34a48dda8a4812e933249e945f66858785947d95168154b18e44f0ffa4f3c0a336ee2fc72f6b0aa1deeba5cd4646e68ae591923dc2894597862a753c3f86409cc19b8b5070de08fdab340618e6fb9370d95bf07670d76cdf320d5bd3bf10c26ec89f47956a4e6f850f751d7480c82cb25f7a48ba167d207d7a3836c7dee679a7ac1e004e0399598994e7542d63e65eb24b41158c66728720000"
#The reason packet 4 [0:2] is dummy
# last \x00 is need to remove !
c = 0x0f4b82b9d771a2625de1339269ead8599308a5119f3c8a3eb2e266f04210c2ac7e5657072ecd5fb777a99a8d57d94e39fa7001dd926ac42e4e9c944cd086868605d59db718caf0738f9983575119e4ae63f84c7a274eba7b39b9dc19a749a9bca7bead0aa75ea8f2c34a48dda8a4812e933249e945f66858785947d95168154b18e44f0ffa4f3c0a336ee2fc72f6b0aa1deeba5cd4646e68ae591923dc2894597862a753c3f86409cc19b8b5070de08fdab340618e6fb9370d95bf07670d76cdf320d5bd3bf10c26ec89f47956a4e6f850f751d7480c82cb25f7a48ba167d207d7a3836c7dee679a7ac1e004e0399598994e7542d63e65eb24b41158c6672872

# d is private key.
# but, I have public key
# so L
pubKey = RSA.importKey(open('sstf.pub','r').read())

e = pubKey.e
n = hex(pubKey.n)
print(f'e is {e}')
print(f'n is {n}') 

m = pow(c,e,int(n,16))
print(type(m))
print(hex(m)) # RSA_encryption_option(&tmp2,32,&v4)
print(len(hex(m)))
md53 = binascii.unhexlify(hex(m)[-64:])
print(md53)

h = hashlib.md5()
h.update(b'A')
h.update(md51)
h.update(md52)
h.update(md53)
key = h.digest()

h = hashlib.md5()
h.update(b'BB')
h.update(md51)
h.update(md52)
h.update(md53)
key += h.digest()

h = hashlib.md5()
h.update(b'CCC')
h.update(md51)
h.update(md52)
h.update(md53)
iv = h.digest()

print(f'key is {key}')
print(f'iv is {iv}')

# packet 8 
# data + padding(\x00)
# no need on exploit

# packet 10
# 64 bytes so need padding
'''
 *((_BYTE *)&a3 + (signed int)AES256_Decrypt((__int64)&buf, 64u, (__int64)&a3)) = 0;
'''
enc = 'dc014f2266d9368dbd6fb5d3fa1d675cc2172ae703872afbadc94dc8cbc8afcda7c1177253fe51114041ad0103bbb86500000000000000000000000000000000'

aes = AES.new(key, AES.MODE_CBC, iv)
print(aes.decrypt(binascii.unhexlify(enc)))
